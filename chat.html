<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memepedia Chat</title>
  <meta property="og:site_name" content="Memepedia Rebirth" />
  <meta name="application-name" content="Memepedia Rebirth" />
  <link rel="canonical" href="https://memepedia.pages.dev/chat" />
  <link rel="icon" href="icon_smaller.jpg" type="image/png" />

  <style>
    body {
      font-family: 'Arial', sans-serif;
      background-color: #000000;
      color: #ffffff;
      margin: 0;
      padding: 0;
      text-align: center;
    }
    header {
      background-color: #cc5500;
      color: #ffffff;
      padding: 20px 0;
    }
    header img {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      margin-bottom: 10px;
    }
    main {
      padding: 30px;
    }
    .button {
      display: inline-block;
      background-color: #cc5500;
      color: white;
      padding: 15px 25px;
      text-decoration: none;
      border-radius: 8px;
      font-size: 16px;
      transition: background-color 0.3s;
      cursor: pointer;
      border: none;
      user-select: none;
    }
    .button:hover {
      background-color: #b34700;
    }
    .button:disabled {
      opacity: 0.65;
      cursor: not-allowed;
    }

    .chat-container {
      margin: 30px auto;
      padding: 20px;
      background-color: #222222;
      border-radius: 8px;
      width: 80%;
      max-width: 900px;
      box-sizing: border-box;
    }
    .messages-container {
      margin-bottom: 20px;
      height: 500px;
      overflow-y: auto;
      background-color: #333333;
      padding: 15px;
      border-radius: 8px;
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 12px;
      scroll-behavior: smooth;
    }
    .message {
      background-color: #444444;
      border-radius: 8px;
      padding: 12px;
      word-wrap: break-word;
      border-left: 4px solid #cc5500;
      position: relative;
    }
    .message .author {
      color: #cc5500;
      font-weight: bold;
      display: block;
      margin-bottom: 5px;
    }
    .message .content {
      color: #ffffff;
    }

    .message.pending {
      opacity: 0.65;
      border-left-color: #ffb067;
    }
    .message.pending::after {
      content: "Sending...";
      position: absolute;
      right: 10px;
      top: 10px;
      font-size: 12px;
      color: #ffb067;
    }
    .message.failed {
      opacity: 0.85;
      border-left-color: #ff4d4d;
    }
    .message.failed::after {
      content: "Failed";
      position: absolute;
      right: 10px;
      top: 10px;
      font-size: 12px;
      color: #ff4d4d;
    }

    .embed-media {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
      margin-top: 10px;
      display: block;
    }

    .input-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 20px;
    }
    .input-container input[type="text"] {
      padding: 10px;
      flex-grow: 1;
      font-size: 16px;
      border-radius: 5px;
      border: none;
      outline: none;
    }
    #uploadBtn {
      padding: 10px 15px;
      min-width: 56px;
    }

    footer {
      background-color: #111;
      color: #aaaaaa;
      padding: 15px 0;
      font-size: 14px;
      margin-top: 50px;
    }

    .messages-container::-webkit-scrollbar { width: 8px; }
    .messages-container::-webkit-scrollbar-track { background: #222; }
    .messages-container::-webkit-scrollbar-thumb { background: #cc5500; border-radius: 4px; }
  </style>
</head>

<body>
  <header>
    <h1>Memepedia Chat</h1>
    <img src="https://github.com/MagicDippyEgg/MEMEPEDIA-CONTENT/blob/main/icon.png?raw=true" alt="Memepedia Logo" />
  </header>

  <main>
    <a href="https://memepedia.pages.dev/" class="button">Back to Home</a>

    <div class="chat-container">
      <div class="messages-container" id="messagesContainer"></div>

      <div class="input-container">
        <input type="file" id="imageInput" accept="image/*,video/*" style="display:none;" />
        <button id="uploadBtn" class="button" title="Upload Image">üì∑</button>

        <input type="text" id="memeInput" placeholder="Type your message here..." />
        <button id="sendMeme" class="button">Send</button>
      </div>
    </div>

    <h2>Synced with #general Discord</h2>
    <iframe
      src="https://discord.com/widget?id=1359467119355494442&theme=dark"
      width="350"
      height="500"
      allowtransparency="true"
      frameborder="0"
      sandbox="allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts"
    ></iframe>
  </main>

  <footer>
    Created by St1cky N0te, with help from Magic Dippy Egg | Memepedia: Rebirth
  </footer>

  <script>
    const messagesContainer = document.getElementById('messagesContainer');
    const memeInput = document.getElementById('memeInput');
    const sendBtn = document.getElementById('sendMeme');
    const uploadBtn = document.getElementById('uploadBtn');
    const imageInput = document.getElementById('imageInput');

    // pending messages so polling does not delete them
    const pendingMessages = new Map(); // clientId -> element

    // pending matcher: key -> clientId (lets us delete the optimistic bubble when server echo arrives)
    const pendingByKey = new Map();

    // track rendered server messages so we only append new ones
    const renderedServerIds = new Set();

    // safety: keep DOM from growing forever
    const MAX_RENDERED_MESSAGES = 250;

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function normalizeTextForKey(s) {
      return String(s || "")
        .trim()
        .replace(/\s+/g, " ")
        .toLowerCase();
    }

    function makePendingKey(content) {
      return "k:" + normalizeTextForKey(content);
    }

    function safeParseUrl(raw) {
      try {
        return new URL(raw);
      } catch {
        return null;
      }
    }

    function extractYouTubeIdFromUrl(rawUrl) {
      const u = safeParseUrl(rawUrl);
      if (!u) return null;

      const host = u.hostname.toLowerCase().replace(/^www\./, "");
      const path = u.pathname;

      // youtube.com/watch?v=VIDEOID
      if (host === "youtube.com" || host === "m.youtube.com" || host === "music.youtube.com") {
        if (path === "/watch") {
          const v = u.searchParams.get("v");
          return v ? v.trim() : null;
        }

        // youtube.com/embed/VIDEOID
        if (path.startsWith("/embed/")) {
          const id = path.split("/embed/")[1]?.split("/")[0];
          return id ? id.trim() : null;
        }

        // youtube.com/shorts/VIDEOID
        if (path.startsWith("/shorts/")) {
          const id = path.split("/shorts/")[1]?.split("/")[0];
          return id ? id.trim() : null;
        }
      }

      // youtu.be/VIDEOID
      if (host === "youtu.be") {
        const id = path.slice(1).split("/")[0];
        return id ? id.trim() : null;
      }

      return null;
    }

    function formatContent(text) {
      if (!text) return '';
      const safe = escapeHtml(text);
      const urlPattern = /(https?:\/\/[^\s]+)/g;

      return safe.replace(urlPattern, (url) => {
        const urlObj = safeParseUrl(url);
        const hostLower = urlObj ? urlObj.hostname.toLowerCase() : "";
        const urlLower = url.toLowerCase();

        // Tenor embed (keep existing logic, but don't destroy original URL)
        if (urlLower.includes('tenor.com/view/')) {
          const lowerUrl = urlLower;
          const parts = lowerUrl.split('-');
          const gifId = parts[parts.length - 1];
          if (gifId) {
            return `
              <br>
              <iframe
                src="https://tenor.com/embed/${gifId}"
                width="100%"
                height="300"
                frameborder="0"
                allowfullscreen
                style="border-radius:8px;">
              </iframe>
              <br>
            `;
          }
        }

        if (urlLower.match(/\.(jpeg|jpg|gif|png|webp)$/)) {
          return `<br><img src="${url}" class="embed-media" loading="lazy" /><br>`;
        }

        if (urlLower.match(/\.(mp4|webm)$/)) {
          return `<br><video controls class="embed-media"><source src="${url}"></video><br>`;
        }

        // YouTube embeds (CASE-SAFE)
        const ytId = extractYouTubeIdFromUrl(url);
        if (ytId) {
          return `
            <br>
            <iframe
              width="100%"
              height="250"
              src="https://www.youtube.com/embed/${ytId}"
              frameborder="0"
              allowfullscreen
              style="border-radius:8px;">
            </iframe>
            <br>
          `;
        }

        return `<a href="${url}" target="_blank" rel="noopener" style="color: #cc5500;">${url}</a>`;
      });
    }

    function isUserNearBottom() {
      return (messagesContainer.scrollHeight - messagesContainer.scrollTop) <= (messagesContainer.clientHeight + 120);
    }

    function setSendUiState(isSending) {
      sendBtn.disabled = isSending;
      sendBtn.textContent = isSending ? "Sending..." : "Send";
    }

    function newClientId() {
      return "c_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2, 8);
    }

    function messageServerId(message) {
      if (message && (message.id || message.message_id || message.messageId)) {
        return String(message.id || message.message_id || message.messageId);
      }
      const author = message?.author?.username || message?.author || "Unknown";
      const content = message?.content || "";
      const ts = message?.timestamp || message?.createdTimestamp || message?.created_at || "";
      const att = Array.isArray(message?.attachments) ? message.attachments.map(a => a?.url || "").join("|") : "";
      return "fp_" + btoa(unescape(encodeURIComponent(author + "||" + content + "||" + ts + "||" + att))).slice(0, 80);
    }

    function buildMessageElement(authorName, contentHtml, opts = {}) {
      const messageElement = document.createElement('div');
      messageElement.classList.add('message');

      if (opts.pending) messageElement.classList.add('pending');
      if (opts.failed) messageElement.classList.add('failed');
      if (opts.clientId) messageElement.dataset.clientId = opts.clientId;
      if (opts.serverId) messageElement.dataset.serverId = opts.serverId;
      if (opts.pendingKey) messageElement.dataset.pendingKey = opts.pendingKey;

      messageElement.innerHTML = `
        <span class="author">${escapeHtml(authorName || 'Unknown')}</span>
        <span class="content">${contentHtml || ''}</span>
      `;

      return messageElement;
    }

    function trimOldMessagesIfNeeded() {
      const all = Array.from(messagesContainer.querySelectorAll(".message"));
      const nonPending = all.filter(el => !el.classList.contains("pending"));
      if (nonPending.length <= MAX_RENDERED_MESSAGES) return;

      const toRemoveCount = nonPending.length - MAX_RENDERED_MESSAGES;
      for (let i = 0; i < toRemoveCount; i++) {
        const el = nonPending[i];
        const sid = el.dataset.serverId;
        if (sid) renderedServerIds.delete(sid);
        el.remove();
      }
    }

    function consumeMatchingPendingIfExists(serverContentText) {
      const key = makePendingKey(serverContentText);
      const clientId = pendingByKey.get(key);
      if (!clientId) return false;

      const pendingEl = pendingMessages.get(clientId);
      if (pendingEl && pendingEl.classList.contains("pending")) {
        pendingEl.remove();
      }

      pendingMessages.delete(clientId);
      pendingByKey.delete(key);
      return true;
    }

    async function fetchMessages() {
      try {
        const response = await fetch('https://memepedia-backend.vercel.app/api/get-latest-messages', { cache: 'no-store' });
        if (!response.ok) throw new Error(`Error: ${response.statusText}`);

        const data = await response.json();
        let messages = Array.isArray(data.messages) ? data.messages : (Array.isArray(data) ? data : []);
        if (messages.length === 0) return;

        messages.reverse();

        const shouldAutoScroll = isUserNearBottom();
        let appendedAny = false;

        for (const message of messages) {
          const sid = messageServerId(message);
          if (renderedServerIds.has(sid)) continue;

          const authorName = message.author?.username || message.author || 'Unknown';
          const rawText = message.content || "";

          consumeMatchingPendingIfExists(rawText);

          let contentHtml = formatContent(rawText);

          if (message.attachments && message.attachments.length > 0) {
            message.attachments.forEach(attachment => {
              const fileUrl = attachment.url;
              const lowerUrl = String(fileUrl || '').toLowerCase();
              if (lowerUrl.match(/\.(jpeg|jpg|gif|png|webp)$/)) {
                contentHtml += `<br><img src="${fileUrl}" class="embed-media" loading="lazy" />`;
              } else if (lowerUrl.match(/\.(mp4|webm)$/)) {
                contentHtml += `<br><video controls class="embed-media"><source src="${fileUrl}"></video>`;
              }
            });
          }

          const messageElement = buildMessageElement(authorName, contentHtml, { serverId: sid });
          messagesContainer.appendChild(messageElement);

          renderedServerIds.add(sid);
          appendedAny = true;
        }

        const pendingNodes = Array.from(pendingMessages.values()).filter(Boolean);
        pendingNodes.forEach(node => {
          if (node.parentElement === messagesContainer) messagesContainer.appendChild(node);
        });

        trimOldMessagesIfNeeded();

        if (shouldAutoScroll && appendedAny) {
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
      } catch (error) {
        console.error('Fetch Error:', error);
      }
    }

    async function sendMessage() {
      const memeContent = memeInput.value.trim();
      if (!memeContent) return;

      const clientId = newClientId();
      const shouldAutoScroll = isUserNearBottom();

      const pendingKey = makePendingKey(memeContent);

      const pendingEl = buildMessageElement("You", formatContent(memeContent), { pending: true, clientId, pendingKey });
      messagesContainer.appendChild(pendingEl);

      pendingMessages.set(clientId, pendingEl);
      pendingByKey.set(pendingKey, clientId);

      if (shouldAutoScroll) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }

      memeInput.value = '';
      setSendUiState(true);

      try {
        const response = await fetch('https://memepedia-backend.vercel.app/api/send-to-discord', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ content: memeContent })
        });

        if (!response.ok) {
          pendingEl.classList.remove('pending');
          pendingEl.classList.add('failed');
          setSendUiState(false);
          return;
        }

        setSendUiState(false);
        fetchMessages();
      } catch (error) {
        console.error(error);
        pendingEl.classList.remove('pending');
        pendingEl.classList.add('failed');
        setSendUiState(false);
      }
    }

    sendBtn.addEventListener('click', sendMessage);

    memeInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendMessage();
      }
    });

    uploadBtn.addEventListener('click', () => imageInput.click());

    imageInput.addEventListener('change', async () => {
      const file = imageInput.files[0];
      if (!file) return;

      uploadBtn.textContent = '‚è≥';
      uploadBtn.disabled = true;

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await fetch('https://memepedia-backend.vercel.app/api/upload-to-catbox', {
          method: 'POST',
          body: formData
        });

        if (response.ok) {
          const data = await response.json();
          memeInput.value = (memeInput.value + " " + data.url).trim();
          memeInput.focus();
        }
      } catch (e) {
        console.error(e);
      } finally {
        uploadBtn.textContent = 'üì∑';
        uploadBtn.disabled = false;
        imageInput.value = '';
      }
    });

    fetchMessages();
    setInterval(fetchMessages, 3000);
  </script>

  <script data-goatcounter="https://magicdippyegg.goatcounter.com/count"
          async src="//gc.zgo.at/count.js"></script>
</body>
</html>
